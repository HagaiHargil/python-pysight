#![feature(uniform_paths)]
#![feature(specialization)]


extern crate failure;
extern crate failure_derive;
#[macro_use] extern crate pyo3;

use std::fs;


use pyo3::prelude::*;
use filebuffer::FileBuffer;

pub mod parsing;
pub mod helper_funcs;

use parsing::*;
use helper_funcs::*;

/// This module is a Python moudle implemented in Rust.
#[pymodinit]
fn libpysight(_py: Python, m: &PyModule) -> PyResult<()> {
   
   #[pyfn(m, "read_binary_lst_u8")]
   fn py_read_lst_u8(py: Python, file_path: String, start_of_data_pos: usize, range: u64, timpatch: String,
            channel_map: Vec<u8>) -> PyResult<LstReturnU8> {
        let result = py.allow_threads(move || analyze_lst_u8(&file_path, start_of_data_pos, range, &timpatch, channel_map));
        Ok(result)
    }

    #[pyfn(m, "read_binary_lst_u16")]
   fn py_read_lst_u16(py: Python, file_path: String, start_of_data_pos: usize, range: u64, timpatch: String,
            channel_map: Vec<u8>) -> PyResult<LstReturnU16> {
        let result = py.allow_threads(move || analyze_lst_u16(&file_path, start_of_data_pos, range, &timpatch, channel_map));
        Ok(result)
    }
    Ok(())
}
/// Parse binary list files generated by a multiscaler.
/// Parameters:
/// fname - str
pub fn analyze_lst_u8(fname: &str, start_of_data: usize, range: u64,
                      timepatch: &str, channel_map: Vec<u8>)
    -> LstReturnU8 {

    // Open the file and convert it to a usable format
    let data_with_headers = FileBuffer::open(fname).expect("bad file name");
    let data = &data_with_headers[start_of_data..];
    let data_size: usize = (fs::metadata(fname).unwrap().len() - start_of_data as u64) as usize;
    let chan_map = create_channel_vec_u8(timepatch, channel_map, data_size);
    let inputs = (data, range, &TimepatchBits::new(timepatch), chan_map);

    let processed_data = match timepatch {
        "2a" => parse_2a(inputs.0, inputs.1, inputs.2, inputs.3),
        "22" => parse_22(inputs.0, inputs.1, inputs.2, inputs.3),
        "3" => parse_3(inputs.0, inputs.1, inputs.2, inputs.3),
        _ => panic!("Invalid timepatch value: {}", timepatch),
    };
    processed_data
}

/// Parse binary list files generated by a multiscaler.
/// Parameters:
/// fname - str
pub fn analyze_lst_u16(fname: &str, start_of_data: usize, range: u64,
                       timepatch: &str, channel_map: Vec<u8>)
    -> LstReturnU16 {

    // Open the file and convert it to a usable format
    let data_with_headers = FileBuffer::open(fname).expect("bad file name");
    let data = &data_with_headers[start_of_data..];
    let data_size: usize = (fs::metadata(fname).unwrap().len() - start_of_data as u64) as usize;
    let chan_map = create_channel_vec_u16(timepatch, channel_map, data_size);

    let inputs = (data, range, &TimepatchBits::new(timepatch), chan_map);

    let processed_data = match timepatch {
        "0" => parse_0(inputs.0, inputs.1, inputs.2, inputs.3),
        "5" => parse_5(inputs.0, inputs.1, inputs.2, inputs.3),
        "1" => parse_1(inputs.0, inputs.1, inputs.2, inputs.3),
        "1a" => parse_1a(inputs.0, inputs.1, inputs.2, inputs.3),
        "32" => parse_32(inputs.0, inputs.1, inputs.2, inputs.3),
        "2" => parse_2(inputs.0, inputs.1, inputs.2, inputs.3),
        "5b" => parse_5b(inputs.0, inputs.1, inputs.2, inputs.3),
        "Db" => parse_Db(inputs.0, inputs.1, inputs.2, inputs.3),
        "f3" => parse_f3(inputs.0, inputs.1, inputs.2, inputs.3),
        "43" => parse_43(inputs.0, inputs.1, inputs.2, inputs.3),
        "c3" => parse_c3(inputs.0, inputs.1, inputs.2, inputs.3),
        _ => panic!("Invalid timepatch value: {}", timepatch),
    };
    processed_data
}
